use crate::scenario::Vendor;
use clap::{Parser, Subcommand};
use clap_complete::Shell;

#[derive(Parser, Debug)]
#[command(name = "benchmark", version, about="falkor benchmark tool", long_about = None, arg_required_else_help(true), propagate_version(true))]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
}

#[derive(Subcommand, Debug)]
pub enum Commands {
    #[command(arg_required_else_help = true)]
    GenerateAutoComplete { shell: Shell },
    #[command(arg_required_else_help = true)]
    #[command(about = "load data into the database")]
    Load {
        #[arg(short, long, value_enum)]
        vendor: Vendor,
        #[arg(short, long, value_enum)]
        size: crate::scenario::Size,
        #[arg(
            short,
            long,
            required = false,
            default_value_t = false,
            default_missing_value = "true",
            help = "execute clear -f before"
        )]
        force: bool,
        #[arg(
            short,
            long,
            required = false,
            default_value_t = false,
            default_missing_value = "true",
            help = "only load the data from the cache and iterate over it, show how much time it takes, do not send it to the server"
        )]
        dry_run: bool,
        #[arg(
            short,
            long,
            required = false,
            default_value_t = 1000,
            help = "number of cypher commands to execute in a single batch"
        )]
        batch_size: usize,
        #[arg(
            short,
            long,
            required = false,
            help = "endpoint for external database connection (e.g., falkor://127.0.0.1:6379)"
        )]
        endpoint: Option<String>,
    },
    #[command(
        about = "generate a set of queries and store them in a file to be used with the run command"
    )]
    GenerateQueries {
        #[arg(short, long, value_enum)]
        vendor: Vendor,
        #[arg(short, long, value_enum)]
        size: usize,
        #[arg(short, long, value_enum)]
        dataset: crate::scenario::Size,
        #[arg(
            short,
            long,
            required = false,
            default_missing_value = "queries.json",
            help = "name of json file to save the queries"
        )]
        name: String,
        #[arg(
            short,
            long,
            value_parser = parse_write_ratio,
            required = true,
            help = "the write ratio of the queries (0.0 - 1.0)"
        )]
        write_ratio: f32,
    },

    #[command(
        about = "run the queries generated by the GenerateQueries command against the chosen vendor"
    )]
    Run {
        #[arg(short, long, value_enum)]
        vendor: Vendor,
        #[arg(
            short,
            long,
            required = false,
            default_value_t = 1,
            default_missing_value = "1",
            help = "parallelism level"
        )]
        parallel: usize,
        #[arg(
            short,
            long,
            required = false,
            default_missing_value = "queries.json",
            help = "name of json file to load the queries from"
        )]
        name: String,
        #[arg(
            short,
            long,
            required = true,
            help = "the rate of messages that sent to the server (messages per second)"
        )]
        mps: usize,
        #[arg(
            short,
            long,
            required = false,
            help = "simulate the benchmark without sending the messages to the server, the value the process time in milliseconds"
        )]
        simulate: Option<usize>,
        #[arg(
            short,
            long,
            required = false,
            help = "endpoint for external database connection (e.g., falkor://127.0.0.1:6379)"
        )]
        endpoint: Option<String>,
        #[arg(
            long,
            required = false,
            help = "base directory to write detailed per-vendor run results (will create <results-dir>/<vendor>/...). Defaults to Results-YYMMDD-HH:MM"
        )]
        results_dir: Option<String>,
    },
    #[command(about = "aggregate per-vendor run results into UI summary JSON files")]
    Aggregate {
        #[arg(
            long,
            required = true,
            help = "run results directory (contains subfolders: falkor/ neo4j/ memgraph/)"
        )]
        results_dir: String,
        #[arg(
            long,
            required = false,
            default_value = "ui/public/summaries",
            help = "directory to write UI summary JSON files"
        )]
        out_dir: String,
    },

    #[command(
        about = "Run each generated Memgraph query type once against a Memgraph endpoint to detect failing queries"
    )]
    DebugMemgraphQueries {
        #[arg(short, long, value_enum)]
        dataset: crate::scenario::Size,
        #[arg(
            short,
            long,
            help = "endpoint for external Memgraph (e.g., bolt://127.0.0.1:7687)",
            required = true,
        )]
        endpoint: String,
        #[arg(
            short,
            long,
            default_value = "small-readonly-memgraph",
            help = "name of json file to load the generated Memgraph queries from",
        )]
        name: String,
    },
}

fn parse_write_ratio(val: &str) -> Result<f32, String> {
    match val.parse::<f32>() {
        Ok(value) if (0.0..=1.0).contains(&value) => Ok(value),
        Ok(_) => Err(String::from("Value must be between 0.0 and 1.0")),
        Err(_) => Err(String::from("Invalid float value")),
    }
}
